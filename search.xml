<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 Hexo 在 GitHub 上搭建博客]]></title>
    <url>%2F2019%2F06%2F29%2Fhexo-gitpages-build-blog.html</url>
    <content type="text"><![CDATA[这是一篇使用Hexo在GitHub上通过GitPages搭建博客的分享 太长不看版Hexo 安装 | 官网1npm install hexo-cli -g Hexo 常用命令 | 官网指令参考123456789101112131415161718192021222324252627282930# 初始化一个Hexo项目hexo init [folder]# 新建一个文件hexo new [layout] &lt;filename&gt;# ex:hexo new draft &lt;filename&gt;# 生成页面hexo generatehexo g# 清除生成的页面hexo clean# 本地服务预览hexo serverhexo s# 发布草稿hexo publish [layout] &lt;filename&gt;# ex:hexo publish draft &lt;filename&gt;# 安装 deploy 插件npm install hexo-deployer-git --save# 部署到GitHubhexo deployhexo d 目录 Hexo介绍 Hexo 是什么 Hexo 能做什么 开始一个Hexo项目 前置依赖 安装 配置你的Hexo项目 尝试编写 预览 部署到GitHub 前置依赖 插件安装 配置并部署 个性化定制 个性化域名 定制文章链接 定制主题 Hexo 高级功能 Hexo 添加插件 参考 hexo史上最全搭建教程 link]]></content>
      <tags>
        <tag>示例</tag>
        <tag>分享</tag>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>GitPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 闭包快速理解]]></title>
    <url>%2F2019%2F05%2F25%2Fjs-closures-quick-understanding.html</url>
    <content type="text"><![CDATA[什么是闭包 来自百度： 闭包就是能够读取其他函数内部变量的函数。 例如在javascript中， 只有函数内部的子函数才能读取局部变量， 所以闭包可以理解成“定义在一个函数内部的函数“。 在本质上， 闭包是将函数内部和函数外部连接起来的桥梁。 个人理解： 闭包可以理解成js版本的封装 为了避免参数污染， 通过在函数内部定义变量， 并通过子函数进行操作， 并讲子函数暴露给外部环境进行引用， 这种程序结构就叫做闭包。 什么是闭包 来自百度： 闭包就是能够读取其他函数内部变量的函数。 例如在javascript中， 只有函数内部的子函数才能读取局部变量， 所以闭包可以理解成“定义在一个函数内部的函数“。 在本质上， 闭包是将函数内部和函数外部连接起来的桥梁。 个人理解： 闭包可以理解成js版本的封装 为了避免参数污染， 通过在函数内部定义变量， 并通过子函数进行操作， 并讲子函数暴露给外部环境进行引用， 这种程序结构就叫做闭包。 举例：当function里嵌套function时， 内部的function可以访问外部function里的变量。 不管执行多少次， 都会alert 16。 123456789function foo(x) &#123; var tmp = 3; function bar(y) &#123; alert(x + y + (++tmp)); &#125; bar(10);&#125;foo(2) 上面的代码运行后的结果并不是闭包， 只是展示内部的function使用对外部function里的变量的过程。 如果你把上面代码中的内部函数bar() 单独返回出去， 并运行他的时候， 内部函数bar() 依然可以访问外部函数foo() 的变量， 这个时候就是闭包。 内部function会close-over外部function的变量直到内部function结束。 12345678function foo(x) &#123; var tmp = 3; return function(y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10); 但是， 由于tmp仍存在于bar闭包的内部， 所以它还是会自加1， 而且你每次调用bar时它都会自加1.]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git客户端的初始化配置]]></title>
    <url>%2F2019%2F05%2F24%2Fgit-cli-init.html</url>
    <content type="text"><![CDATA[最近更换了工作的电脑， 然后需要重新配置Git环境， 找来找去挺麻烦的， 所以做个笔记。 用户设置12git config--global user.name &quot;John Doe&quot;git config--global user.email &quot;johndoe@example.com&quot; SSH公钥设置命令： 生成公钥 123456789101112$ ssh - keygenGenerating public / private rsa key pair.Enter file in which to save the key(/home/schacon / .ssh / id_rsa): Created directory &apos;/home/schacon/.ssh&apos;.Enter passphrase(empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/schacon / .ssh / id_rsa.Your public key has been saved in /home/schacon / .ssh / id_rsa.pub.The key fingerprint is: d0: 82: 24: 8 e: d7: f1: bb: 9 b: 33: 53: 96: 93: 49: da: 9 b: e3 schacon @mylaptop.local 命令： 查看已有的公钥 12345// 确认是否有公钥$ cd~/.ssh$ lsauthorized_keys2 id_dsa known_hostsconfig id_dsa.pub 说明如前所述， 许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥， 如果某系统用户尚未拥有密钥， 必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先， 你需要确认自己是否已经拥有密钥。 默认情况下， 用户的 SSH 密钥存储在其 ~/.ssh 目录下。 进入该目录并列出其中内容， 你便可以快速确认自己是否已拥有密钥： 12345// 确认是否有公钥$ cd~/.ssh$ lsauthorized_keys2 id_dsa known_hostsconfig id_dsa.pub 我们需要寻找一对以 id_dsa 或 id_rsa 命名的文件， 其中一个带有 .pub 扩展名。 .pub 文件是你的公钥， 另一个则是私钥。 如果找不到这样的文件（或者根本没有 .ssh 目录）， 你可以通过运行 ssh-keygen 程序来创建它们。 在 Linux/Mac 系统中， ssh-keygen 随 SSH 软件包提供； 在 Windows 上， 该程序包含于 MSysGit 软件包中。 1234567891011$ ssh - keygenGenerating public / private rsa key pair.Enter file in which to save the key(/home/schacon / .ssh / id_rsa): Created directory &apos;/home/schacon/.ssh&apos;.Enter passphrase(empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/schacon / .ssh / id_rsa.Your public key has been saved in /home/schacon / .ssh / id_rsa.pub.The key fingerprint is: d0: 82: 24: 8 e: d7: f1: bb: 9 b: 33: 53: 96: 93: 49: da: 9 b: e3 schacon @mylaptop.local 首先 ssh-keygen 会确认密钥的存储位置（默认是 .ssh/id_rsa）， 然后它会要求你输入两次密钥口令。 如果你不想在使用密钥时输入口令， 将其留空即可。 现在， 进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员（假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 .pub 文件内容， 并将其通过邮件发送。 公钥看起来是这样的： 1234567$ cat~/.ssh/id_rsa.pubssh - rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom / BWDSUGPl + nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ / MTyBlWXFCR + HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK / 7 XAt3FaoJoAsncM1Q9x5 + 3 V0Ww68 / eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw / Pb0rwert / EnmZ + AW4OZPnTPI89ZPmVMLuayrD2cE86Z / il8b + gw3r3 + 1n KatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf + M7Q == schacon @mylaptop.local]]></content>
      <tags>
        <tag>Git</tag>
        <tag>命令</tag>
        <tag>示例</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok 服务的搭建过程]]></title>
    <url>%2F2019%2F05%2F24%2Fbuild-ngrok-service.html</url>
    <content type="text"><![CDATA[前段时间为了做微信的相关功能， 需要在开发机器上直接调试， 所以搞了个内网穿透， 今天把搭建过程记录一下。 大纲 一、 如何用一分钟实现ngrok内网穿透 二、 ngrok的作用 三、 材料 四、 搭建过程 事前准备 下载ngrok源码 ssl证书 安装编译环境 编译 运行 五、 注意事项 一、 如何用一分钟实现ngrok内网穿透安装ngrok， 开启服务， 完成。 本次分享到此结束。 二、 ngrok的作用网络十分发达， 但是大部分网络以局域网的形式存在， 无法直接访问。 所以需要内网穿透 三、 需要用到的材料 一台具有公网ip的服务器 一个域名， 有备案最好（示例域名： tunnel.emok.top） 一堆依赖的工具， 包括但不限于： git gcc wget 四、 搭建过程目前搭建的方案大都是 ： 事前准备》2. 安装编译环境 》 3. 下载源码 》 4. 获取证书 》 5. 编译 》 6. 运行。 其中2-4步是可以并行进行， 不需要按顺序的。 流程图如下： 1234567891011121314graph TBA[-事前准备 - ]B1[-ngrok源码 - ]B2[-ssl证书 - ]B3[-编译环境 - ]C[-编译ngrok - ]D[-运行服务端 - ]A-- &gt; B1A-- &gt; B2A-- &gt; B3B1-- &gt; CB2-- &gt; CB3-- &gt; CC-- &gt; D 事前准备事前准备分为两个步骤， 一个是域名解析， 一个是依赖安装。域名解析需要到域名服务商那里设置用于ngrok的域名的服务器地址解析， 以及该域名子域名的解析。依赖安装是指搭建过程中需要用到的一些底层工具， 包括Git、 gcc、 wget等。 123#CentOS 7yum -y install zlib-devel openssl-devel perl hg cpio expat-devel gettext-devel curl curl-devel perl-ExtUtils-MakeMaker hg wget gcc gcc-c++ 下载ngrok源码下载ngrok的源码是通过Git工具到Github上下载的， 一般Linux默认有Git工具， 如果没有， 可以自己安装（安装方式不限于apt、 yum、 下载安装）。 123#CentOSyum –y install git 或者可以下载Git安装包进行安装， 参考 这篇文章 安装完使用克隆命令将ngrok代码克隆到某个路径 123#git clone[git url]git clone https: //github.com/inconshreveable/ngrok.git 安装结果如图： 获取SSL证书运行ngrok服务需要ssl证书的支持， 一般用于商业服务的ssl证书都是花钱购买别的机构颁发的证书， 这里我们选择自己生成一个证书， 缺点是只能用于自己的服务， 但是对我们来说足够了。 首先需要安装生成证书所需的工具 open-ssl 123#CentOSyum install open-ssl 然后为了便于管理， 我们可以新建一个目录来存放ssl证书。 12mkdir certcd cert 然后生成ssl证书 生成SSL证书时使用的域名要和准备搭载ngrok服务的域名一致。 1234567#ssl# 指令中的$NGROK_DOMAIN替换成准备的域名openssl genrsa - out rootCA.key 2048openssl req - x509 - new - nodes - key rootCA.key - subj &quot;/CN=$NGROK_DOMAIN&quot; - days 5000 - out rootCA.pemopenssl genrsa - out server.key 2048openssl req - new - key server.key - subj &quot;/CN=$NGROK_DOMAIN&quot; - out server.csropenssl x509 - req - in server.csr - CA rootCA.pem - CAkey rootCA.key - CAcreateserial - out server.crt - days 5000 生成过程中遇到 yes or no 可以直接yes， 遇到需要输入的地方也可以直接回车继续。生成完成后会有如图的 6 个文件： 然后我们将其中的 rootCA.pem 、 server.crt 、 server.key 三个文件复制到 ngrok 的 assets 目录下， 覆盖原来的默认证书。 123cp rootCA.pem ngrok / assets / client / tls / ngrokroot.crtcp server.crt ngrok / assets / server / tls / snakeoil.crtcp server.key ngrok / assets / server / tls / snakeoil.key 如果还没下载源码就先下载源码后在执行覆盖 安装编译环境 假设已经安装好依赖环境。 编译的依赖环境为Golang。go的安装可以通过下载源码， 然后编译安装， 也可以直接下载go安装， 后者相对简单一点。我们为了简单， 直接下载go的压缩包， 下载下来解压就可以用。去官网(https://golang.org/dl/)下载go1.4的安装包， 以及最新版本的压缩包， 要选择kind为Archive的。 后面会解释为什么要下载两个版本。下载后放在服务器上顺眼的地方， 然后运行安装， 基本都默认就可以。 需要说明的是， go1.4 之后的版本是需要基于go1.4 进行自编译， 所以需要安装两次go环境， 一次是安装go1.4， 第二次是安装更新的版本（一般是最新的稳定版）。 至于为什么要安装最新的go稳定版是因为go1.4会在编译ngrok的过程中出错。 安装完go后需要配置go的环境配置， 后续的编译要用到。 1234export GOPATH = /usr/local / ngrok / export GOROOT = /usr/local / go / export GOROOT_BOOTSTRAP = /usr/local / go / #添加 pathexport PATH = $PATH: /usr/local / go / bin 编译通过go语言的指令进行编译， 需要编译一个服务端和需要的客户端。 编译过程本身没有难度， 只要go环境没问题， 一般都不会报错。 需要注意一点， 编译客户端的参数要和需要运行的目标系统及其位数匹配 编译服务端Linux 64位： 12345678#Linux 64cd / usr / local / go / srcGOOS = linux GOARCH = amd64 . / make.bashcd / usr / local / ngrok / GOOS = linux GOARCH = amd64make release - server 编译客户端Windows 64的版本： 12345678#Windows 64cd / usr / local / go / srcGOOS = windows GOARCH = amd64 . / make.bashcd / usr / local / ngrok / GOOS = windows GOARCH = amd64make release - client Mac 64： 12345678#Mac 64cd / usr / local / go / srcGOOS = darwin GOARCH = amd64 . / make.bashcd / usr / local / ngrok / GOOS = darwin GOARCH = amd64make release - client 运行运行服务端 1234#ngrok# 指令中的$NGROK_DOMAIN替换成准备的域名 / usr / local / ngrok / bin / ngrokd - domain = &quot;$NGROK_DOMAIN&quot; - httpAddr = &quot;:80&quot; 客户端配置文件格式新建配置文件ngrok.cfg， 内容如下： 1234#ngrok client option: ngrok.cfgserver_addr: &quot;tunnel.hanyz.cn:4443&quot;trust_host_root_certs: false 客户端运行指令 123#ngrok . / ngrok - config = . / ngrok.cfg - subdomain abc 80 五、 注意事项 &amp; 解答 编译安装golang的时候遇到以下报错： 12ngrok package net / http / httptrace: unrecognizedimport path &quot;net/http/httptrace&quot; 解决： 安装go最新稳定版 安装最新版golang时遇到以下报错： 1$GOPATH must not be set to $GOROOT 解决： 设置GOROOT 安装最新版golang时遇到以下报错： 1Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4. 解决： 先安装1 .4 再安装最新版 启动客户端后访问页面提示 ： tunnel not found 123456// 如果是以下面的命令启动的，建议将 -httpsAddr 参数块与 -httpAddr 参数调换位置//由~/ngrok/bin / ngrokd - domain = &quot;$NGROK_DOMAIN&quot; - httpAddr = &quot;:80&quot; - httpsAddr = &quot;:443&quot; //改为： ~/ngrok/bin / ngrokd - domain = &quot;$NGROK_DOMAIN&quot; - httpsAddr = &quot;:443&quot; - httpAddr = &quot;:80&quot;// 经试验有效，但是原因未知 参考：sunny博客自己服务器搭建NGROK]]></content>
      <tags>
        <tag>示例</tag>
        <tag>笔记</tag>
        <tag>ngrok</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F15%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
